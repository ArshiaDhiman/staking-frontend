{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Arshia Dhiman/Solidity-Staking-Project/staking-frontend/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"C:/Users/Arshia Dhiman/Solidity-Staking-Project/staking-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { createSlice } from \"@reduxjs/toolkit\";\nimport { STAKING_ADDRESS } from \"src/constants\";\nimport ABI from \"src/abi/Staking.json\";\nimport { getContract, parseBalance } from \"src/utils\"; // Define a type for the slice state\n\n// Define the initial state using that type\nvar initialState = {\n  pools: []\n};\nexport var stakingSlice = createSlice({\n  name: \"staking\",\n  // `createSlice` will infer the state type from the `initialState` argument\n  initialState: initialState,\n  reducers: {\n    setPools: function setPools(state, action) {\n      state.pools = action.payload;\n    }\n  }\n}); // whatever function the thunk returns should use .then (can't await)\n\nexport var updatePools = function updatePools(account) {\n  return function (dispatch) {\n    var staking = getContract(STAKING_ADDRESS, ABI); // eslint-disable-next-line\n\n    staking.getPools().then( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_pools) {\n        var pools;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return Promise.all(_pools.map( /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2, id) {\n                    var poolName, rewardRate, lockPeriod, totalStaked, user_info, user_amount, user_reward, _user_deposit_time, _user_amount, _user_reward;\n\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            poolName = _ref2.poolName, rewardRate = _ref2.rewardRate, lockPeriod = _ref2.lockPeriod, totalStaked = _ref2.totalStaked;\n                            user_info = \"0\";\n                            user_amount = \"0\";\n                            user_reward = \"0\";\n\n                            if (!account) {\n                              _context.next = 8;\n                              break;\n                            }\n\n                            _context.next = 7;\n                            return staking.getStakeholderInfo(id, account);\n\n                          case 7:\n                            user_info = _context.sent;\n\n                          case 8:\n                            _user_deposit_time = parseBalance(user_info[0]);\n                            _user_amount = parseBalance(user_info[1]);\n                            _user_reward = parseBalance(user_info[2]);\n                            return _context.abrupt(\"return\", {\n                              name: poolName,\n                              rewardRate: rewardRate.toString(),\n                              lockPeriod: lockPeriod.toString(),\n                              totalStaked: totalStaked.toString(),\n                              id: id,\n                              user_deposit_time: _user_deposit_time.toString(),\n                              user_amount: _user_amount.toString(),\n                              user_reward: _user_reward.toString()\n                            });\n\n                          case 12:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x2, _x3) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }()));\n\n              case 2:\n                pools = _context2.sent;\n                dispatch(setPools(pools));\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  };\n}; // setPools is an action\n\nvar setPools = stakingSlice.actions.setPools;\nexport { setPools };\nexport default stakingSlice.reducer;","map":{"version":3,"sources":["C:/Users/Arshia Dhiman/Solidity-Staking-Project/staking-frontend/src/features/staking/stakingSlice.ts"],"names":["createSlice","STAKING_ADDRESS","ABI","getContract","parseBalance","initialState","pools","stakingSlice","name","reducers","setPools","state","action","payload","updatePools","account","dispatch","staking","getPools","then","_pools","Promise","all","map","id","poolName","rewardRate","lockPeriod","totalStaked","user_info","user_amount","user_reward","getStakeholderInfo","_user_deposit_time","_user_amount","_user_reward","toString","user_deposit_time","actions","reducer"],"mappings":"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","sourcesContent":["import {\n    createSlice,\n    PayloadAction,\n    ThunkDispatch,\n    Action,\n} from \"@reduxjs/toolkit\";\nimport { RootState } from \"@src/store\";\nimport { Pool } from \"@ts/interfaces\";\n\nimport { STAKING_ADDRESS } from \"src/constants\";\nimport ABI from \"src/abi/Staking.json\";\nimport { getContract, parseBalance } from \"src/utils\";\n\n// Define a type for the slice state\ninterface StakingState {\n    pools: Pool[];\n}\n\n// Define the initial state using that type\nconst initialState: StakingState = {\n    pools: [],\n};\n\nexport const stakingSlice = createSlice({\n    name: \"staking\",\n    // `createSlice` will infer the state type from the `initialState` argument\n    initialState,\n    reducers: {\n        setPools: (state, action: PayloadAction<Pool[]>) => {\n            state.pools = action.payload;\n        },\n    },\n});\n\n// whatever function the thunk returns should use .then (can't await)\nexport const updatePools = (account?: string) => {\n    return (dispatch: ThunkDispatch<RootState, void, Action>): void => {\n        const staking = getContract(STAKING_ADDRESS, ABI);\n        // eslint-disable-next-line\n        staking.getPools().then(async (_pools: any[]) => {\n            const pools = await Promise.all(\n                _pools.map(\n                    async (\n                        { poolName, rewardRate, lockPeriod, totalStaked },\n                        id,\n                    ) => {\n                        let user_info = \"0\";\n                        let user_amount = \"0\";\n                        let user_reward = \"0\";\n\n                        if (account) {\n                            user_info = await staking.getStakeholderInfo(\n                                id,\n                                account,\n                            );\n\n                            // console.log(parseBalance(user_info[1]));\n                        }\n                        const _user_deposit_time = parseBalance(user_info[0]);\n                        const _user_amount = parseBalance(user_info[1]);\n                        const _user_reward = parseBalance(user_info[2]);\n\n                        return {\n                            name: poolName,\n                            rewardRate: rewardRate.toString(),\n                            lockPeriod: lockPeriod.toString(),\n                            totalStaked: totalStaked.toString(),\n                            id: id,\n                            user_deposit_time: _user_deposit_time.toString(),\n                            user_amount: _user_amount.toString(),\n                            user_reward: _user_reward.toString(),\n                        };\n                    },\n                ),\n            );\n\n            dispatch(setPools(pools));\n        });\n    };\n};\n\n// setPools is an action\nexport const { setPools } = stakingSlice.actions;\n\nexport default stakingSlice.reducer;\n"]},"metadata":{},"sourceType":"module"}