{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Arshia Dhiman/Solidity-Staking-Project/staking-frontend/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"C:/Users/Arshia Dhiman/Solidity-Staking-Project/staking-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { createSlice } from \"@reduxjs/toolkit\";\nimport { STAKING_ADDRESS } from \"src/constants\";\nimport ABI from \"src/abi/Staking.json\";\nimport { getContract } from \"src/utils\"; // Define a type for the slice state\n\n// Define the initial state using that type\nvar initialState = {\n  pools: []\n};\nexport var stakingSlice = createSlice({\n  name: \"staking\",\n  // `createSlice` will infer the state type from the `initialState` argument\n  initialState: initialState,\n  reducers: {\n    setPools: function setPools(state, action) {\n      state.pools = action.payload;\n    }\n  }\n});\nexport var updatePools = function updatePools(account) {\n  var staking = getContract(STAKING_ADDRESS, ABI);\n  return function (dispatch) {\n    // eslint-disable-next-line\n    staking.getPools().then( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_pools) {\n        var pools;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return Promise.all(_pools.map( /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2, id) {\n                    var poolName, rewardRate, lockPeriod, totalStaked;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            poolName = _ref2.poolName, rewardRate = _ref2.rewardRate, lockPeriod = _ref2.lockPeriod, totalStaked = _ref2.totalStaked;\n                            return _context.abrupt(\"return\", {\n                              name: poolName,\n                              rewardRate: rewardRate.toString(),\n                              lockPeriod: lockPeriod.toString(),\n                              totalStaked: totalStaked.toString(),\n                              id: id\n                            });\n\n                          case 2:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x2, _x3) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }()));\n\n              case 2:\n                pools = _context2.sent;\n                dispatch(setPools(pools));\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  };\n}; // setPools is an action\n\nvar setPools = stakingSlice.actions.setPools;\nexport { setPools };\nexport default stakingSlice.reducer;","map":{"version":3,"sources":["C:/Users/Arshia Dhiman/Solidity-Staking-Project/staking-frontend/src/features/staking.ts/stakingSlice.ts"],"names":["createSlice","STAKING_ADDRESS","ABI","getContract","initialState","pools","stakingSlice","name","reducers","setPools","state","action","payload","updatePools","account","staking","dispatch","getPools","then","_pools","Promise","all","map","id","poolName","rewardRate","lockPeriod","totalStaked","toString","actions","reducer"],"mappings":";;AAAA,SACIA,WADJ,QAKO,kBALP;AASA,SAASC,eAAT,QAAgC,eAAhC;AACA,OAAOC,GAAP,MAAgB,sBAAhB;AACA,SAASC,WAAT,QAA4B,WAA5B,C,CAEA;;AAKA;AACA,IAAMC,YAA0B,GAAG;AAC/BC,EAAAA,KAAK,EAAE;AADwB,CAAnC;AAIA,OAAO,IAAMC,YAAY,GAAGN,WAAW,CAAC;AACpCO,EAAAA,IAAI,EAAE,SAD8B;AAEpC;AACAH,EAAAA,YAAY,EAAZA,YAHoC;AAIpCI,EAAAA,QAAQ,EAAE;AACNC,IAAAA,QAAQ,EAAE,kBAACC,KAAD,EAAQC,MAAR,EAA0C;AAChDD,MAAAA,KAAK,CAACL,KAAN,GAAcM,MAAM,CAACC,OAArB;AACH;AAHK;AAJ0B,CAAD,CAAhC;AAWP,OAAO,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAACC,OAAD,EAAsB;AAC7C,MAAMC,OAAO,GAAGZ,WAAW,CAACF,eAAD,EAAkBC,GAAlB,CAA3B;AACA,SAAO,UAACc,QAAD,EAAsD;AACzD;AACAD,IAAAA,OAAO,CAACE,QAAR,GAAmBC,IAAnB;AAAA,0EAAwB,kBAAOC,MAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACAC,OAAO,CAACC,GAAR,CAChBF,MAAM,CAACG,GAAP;AAAA,uFACI,wBAEIC,EAFJ;AAAA;AAAA;AAAA;AAAA;AAAA;AACMC,4BAAAA,QADN,SACMA,QADN,EACgBC,UADhB,SACgBA,UADhB,EAC4BC,UAD5B,SAC4BA,UAD5B,EACwCC,WADxC,SACwCA,WADxC;AAAA,6DAIW;AACHpB,8BAAAA,IAAI,EAAEiB,QADH;AAEHC,8BAAAA,UAAU,EAAEA,UAAU,CAACG,QAAX,EAFT;AAGHF,8BAAAA,UAAU,EAAEA,UAAU,CAACE,QAAX,EAHT;AAIHD,8BAAAA,WAAW,EAAEA,WAAW,CAACC,QAAZ,EAJV;AAKHL,8BAAAA,EAAE,EAAEA;AALD,6BAJX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBADJ;;AAAA;AAAA;AAAA;AAAA,oBADgB,CADA;;AAAA;AACdlB,gBAAAA,KADc;AAkBpBW,gBAAAA,QAAQ,CAACP,QAAQ,CAACJ,KAAD,CAAT,CAAR;;AAlBoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAxB;;AAAA;AAAA;AAAA;AAAA;AAoBH,GAtBD;AAuBH,CAzBM,C,CA2BP;;IAEeI,Q,GAAaH,YAAY,CAACuB,O,CAA1BpB,Q;;AAEf,eAAeH,YAAY,CAACwB,OAA5B","sourcesContent":["import {\n    createSlice,\n    PayloadAction,\n    ThunkDispatch,\n    Action,\n} from \"@reduxjs/toolkit\";\nimport { RootState } from \"@src/store\";\nimport { Pool } from \"@ts/interfaces\";\n\nimport { STAKING_ADDRESS } from \"src/constants\";\nimport ABI from \"src/abi/Staking.json\";\nimport { getContract } from \"src/utils\";\n\n// Define a type for the slice state\ninterface StakingState {\n    pools: Pool[];\n}\n\n// Define the initial state using that type\nconst initialState: StakingState = {\n    pools: [],\n};\n\nexport const stakingSlice = createSlice({\n    name: \"staking\",\n    // `createSlice` will infer the state type from the `initialState` argument\n    initialState,\n    reducers: {\n        setPools: (state, action: PayloadAction<Pool[]>) => {\n            state.pools = action.payload;\n        },\n    },\n});\n\nexport const updatePools = (account?: string) => {\n    const staking = getContract(STAKING_ADDRESS, ABI);\n    return (dispatch: ThunkDispatch<RootState, void, Action>) => {\n        // eslint-disable-next-line\n        staking.getPools().then(async (_pools: any[]) => {\n            const pools = await Promise.all(\n                _pools.map(\n                    async (\n                        { poolName, rewardRate, lockPeriod, totalStaked },\n                        id,\n                    ) => {\n                        return {\n                            name: poolName,\n                            rewardRate: rewardRate.toString(),\n                            lockPeriod: lockPeriod.toString(),\n                            totalStaked: totalStaked.toString(),\n                            id: id,\n                        };\n                    },\n                ),\n            );\n\n            dispatch(setPools(pools));\n        });\n    };\n};\n\n// setPools is an action\n\nexport const { setPools } = stakingSlice.actions;\n\nexport default stakingSlice.reducer;\n"]},"metadata":{},"sourceType":"module"}