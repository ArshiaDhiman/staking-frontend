{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Arshia Dhiman/Solidity-Staking-Project/staking-frontend/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"C:/Users/Arshia Dhiman/Solidity-Staking-Project/staking-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { createSlice } from \"@reduxjs/toolkit\";\nimport { STAKING_ADDRESS } from \"src/constants\";\nimport ABI from \"src/abi/Staking.json\";\nimport { getContract } from \"src/utils\"; // Define a type for the slice state\n\n// Define the initial state using that type\nvar initialState = {\n  pools: []\n};\nexport var stakingSlice = createSlice({\n  name: \"staking\",\n  // `createSlice` will infer the state type from the `initialState` argument\n  initialState: initialState,\n  reducers: {\n    setPools: function setPools(state, action) {\n      state.pools = action.payload;\n    }\n  }\n}); // whatever function the thunk returns should use .then (can't await)\n\nexport var updatePools = function updatePools(account) {\n  return function (dispatch) {\n    var staking = getContract(STAKING_ADDRESS, ABI); // eslint-disable-next-line\n\n    staking.getPools().then( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_pools) {\n        var pools;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return Promise.all(_pools.map( /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2, id) {\n                    var poolName, rewardRate, lockPeriod, totalStaked, user_stake, user_reward;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            poolName = _ref2.poolName, rewardRate = _ref2.rewardRate, lockPeriod = _ref2.lockPeriod, totalStaked = _ref2.totalStaked;\n                            user_stake = \"0\";\n                            user_reward = \"0\";\n\n                            if (!account) {\n                              _context.next = 10;\n                              break;\n                            }\n\n                            _context.next = 6;\n                            return staking.getAmountStaked(id, account);\n\n                          case 6:\n                            user_stake = _context.sent.toString();\n                            _context.next = 9;\n                            return staking.calculateReward(id, account);\n\n                          case 9:\n                            user_reward = _context.sent.toString();\n\n                          case 10:\n                            return _context.abrupt(\"return\", {\n                              name: poolName,\n                              rewardRate: rewardRate.toString(),\n                              lockPeriod: lockPeriod.toString(),\n                              totalStaked: totalStaked.toString(),\n                              id: id,\n                              user_stake: user_stake,\n                              user_reward: user_reward\n                            });\n\n                          case 11:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x2, _x3) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }()));\n\n              case 2:\n                pools = _context2.sent;\n                dispatch(setPools(pools));\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  };\n}; // setPools is an action\n\nvar setPools = stakingSlice.actions.setPools;\nexport { setPools };\nexport default stakingSlice.reducer;","map":{"version":3,"sources":["C:/Users/Arshia Dhiman/Solidity-Staking-Project/staking-frontend/src/features/staking.ts/stakingSlice.ts"],"names":["createSlice","STAKING_ADDRESS","ABI","getContract","initialState","pools","stakingSlice","name","reducers","setPools","state","action","payload","updatePools","account","dispatch","staking","getPools","then","_pools","Promise","all","map","id","poolName","rewardRate","lockPeriod","totalStaked","user_stake","user_reward","getAmountStaked","toString","calculateReward","actions","reducer"],"mappings":";;AAAA,SACIA,WADJ,QAKO,kBALP;AASA,SAASC,eAAT,QAAgC,eAAhC;AACA,OAAOC,GAAP,MAAgB,sBAAhB;AACA,SAASC,WAAT,QAA4B,WAA5B,C,CAEA;;AAKA;AACA,IAAMC,YAA0B,GAAG;AAC/BC,EAAAA,KAAK,EAAE;AADwB,CAAnC;AAIA,OAAO,IAAMC,YAAY,GAAGN,WAAW,CAAC;AACpCO,EAAAA,IAAI,EAAE,SAD8B;AAEpC;AACAH,EAAAA,YAAY,EAAZA,YAHoC;AAIpCI,EAAAA,QAAQ,EAAE;AACNC,IAAAA,QAAQ,EAAE,kBAACC,KAAD,EAAQC,MAAR,EAA0C;AAChDD,MAAAA,KAAK,CAACL,KAAN,GAAcM,MAAM,CAACC,OAArB;AACH;AAHK;AAJ0B,CAAD,CAAhC,C,CAWP;;AACA,OAAO,IAAMC,WAAW,GACpB,SADSA,WACT,CAACC,OAAD;AAAA,SACA,UAACC,QAAD,EAAsD;AAClD,QAAMC,OAAO,GAAGb,WAAW,CAACF,eAAD,EAAkBC,GAAlB,CAA3B,CADkD,CAElD;;AACAc,IAAAA,OAAO,CAACC,QAAR,GAAmBC,IAAnB;AAAA,0EAAwB,kBAAOC,MAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACAC,OAAO,CAACC,GAAR,CAChBF,MAAM,CAACG,GAAP;AAAA,uFACI,wBAEIC,EAFJ;AAAA;AAAA;AAAA;AAAA;AAAA;AACMC,4BAAAA,QADN,SACMA,QADN,EACgBC,UADhB,SACgBA,UADhB,EAC4BC,UAD5B,SAC4BA,UAD5B,EACwCC,WADxC,SACwCA,WADxC;AAIQC,4BAAAA,UAJR,GAIqB,GAJrB;AAKQC,4BAAAA,WALR,GAKsB,GALtB;;AAAA,iCAOQf,OAPR;AAAA;AAAA;AAAA;;AAAA;AAAA,mCASkBE,OAAO,CAACc,eAAR,CAAwBP,EAAxB,EAA4BT,OAA5B,CATlB;;AAAA;AAQQc,4BAAAA,UARR,iBAUUG,QAVV;AAAA;AAAA,mCAYkBf,OAAO,CAACgB,eAAR,CAAwBT,EAAxB,EAA4BT,OAA5B,CAZlB;;AAAA;AAWQe,4BAAAA,WAXR,iBAaUE,QAbV;;AAAA;AAAA,6DAgBW;AACHxB,8BAAAA,IAAI,EAAEiB,QADH;AAEHC,8BAAAA,UAAU,EAAEA,UAAU,CAACM,QAAX,EAFT;AAGHL,8BAAAA,UAAU,EAAEA,UAAU,CAACK,QAAX,EAHT;AAIHJ,8BAAAA,WAAW,EAAEA,WAAW,CAACI,QAAZ,EAJV;AAKHR,8BAAAA,EAAE,EAAEA,EALD;AAMHK,8BAAAA,UAAU,EAAVA,UANG;AAOHC,8BAAAA,WAAW,EAAXA;AAPG,6BAhBX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBADJ;;AAAA;AAAA;AAAA;AAAA,oBADgB,CADA;;AAAA;AACdxB,gBAAAA,KADc;AAgCpBU,gBAAAA,QAAQ,CAACN,QAAQ,CAACJ,KAAD,CAAT,CAAR;;AAhCoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAxB;;AAAA;AAAA;AAAA;AAAA;AAkCH,GAtCD;AAAA,CADG,C,CAyCP;;IAEeI,Q,GAAaH,YAAY,CAAC2B,O,CAA1BxB,Q;;AAEf,eAAeH,YAAY,CAAC4B,OAA5B","sourcesContent":["import {\n    createSlice,\n    PayloadAction,\n    ThunkDispatch,\n    Action,\n} from \"@reduxjs/toolkit\";\nimport { RootState } from \"@src/store\";\nimport { Pool } from \"@ts/interfaces\";\n\nimport { STAKING_ADDRESS } from \"src/constants\";\nimport ABI from \"src/abi/Staking.json\";\nimport { getContract } from \"src/utils\";\n\n// Define a type for the slice state\ninterface StakingState {\n    pools: Pool[];\n}\n\n// Define the initial state using that type\nconst initialState: StakingState = {\n    pools: [],\n};\n\nexport const stakingSlice = createSlice({\n    name: \"staking\",\n    // `createSlice` will infer the state type from the `initialState` argument\n    initialState,\n    reducers: {\n        setPools: (state, action: PayloadAction<Pool[]>) => {\n            state.pools = action.payload;\n        },\n    },\n});\n\n// whatever function the thunk returns should use .then (can't await)\nexport const updatePools =\n    (account?: string) =>\n    (dispatch: ThunkDispatch<RootState, void, Action>) => {\n        const staking = getContract(STAKING_ADDRESS, ABI);\n        // eslint-disable-next-line\n        staking.getPools().then(async (_pools: any[]) => {\n            const pools = await Promise.all(\n                _pools.map(\n                    async (\n                        { poolName, rewardRate, lockPeriod, totalStaked },\n                        id,\n                    ) => {\n                        let user_stake = \"0\";\n                        let user_reward = \"0\";\n\n                        if (account) {\n                            user_stake = (\n                                await staking.getAmountStaked(id, account)\n                            ).toString();\n                            user_reward = (\n                                await staking.calculateReward(id, account)\n                            ).toString();\n                        }\n\n                        return {\n                            name: poolName,\n                            rewardRate: rewardRate.toString(),\n                            lockPeriod: lockPeriod.toString(),\n                            totalStaked: totalStaked.toString(),\n                            id: id,\n                            user_stake,\n                            user_reward,\n                        };\n                    },\n                ),\n            );\n\n            dispatch(setPools(pools));\n        });\n    };\n\n// setPools is an action\n\nexport const { setPools } = stakingSlice.actions;\n\nexport default stakingSlice.reducer;\n"]},"metadata":{},"sourceType":"module"}